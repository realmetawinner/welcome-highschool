<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Color Connect - 회로 연결 미션</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root {
      /* 기본 셀 크기 - 모바일 대응을 위해 변수로 관리 */
      --cell-size: 60px;
      --red: #F44336;
      --yellow: #FBC02D;
      --blue: #2196F3;
      --purple: #9C27B0;
    }

    /* 화면이 매우 작은 경우 셀 크기 축소 */
    @media (max-width: 360px) {
      :root {
        --cell-size: 50px;
      }
    }

    body {
      margin: 0;
      padding: 0;
      background: #f8f9fa;
      font-family: 'Pretendard', 'Arial', sans-serif;
    }

    .game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px 15px;
      min-height: 100vh;
      width: 100%;
      max-width: 500px;
      margin: 0 auto;
    }

    /* 이미지 순차 배치 스타일 (세로 적층) */
    .image-stack {
      display: flex;
      flex-direction: column;
      gap: 15px;
      width: 100%;
      margin-bottom: 25px;
    }
    
    .image-stack img {
      width: 100%;
      height: auto;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.08);
      object-fit: cover;
    }

    /* 게임 보드 스타일 */
    #game {
      position: relative;
      width: calc(var(--cell-size) * 5);
      height: calc(var(--cell-size) * 7);
      background: white;
      box-shadow: 0 10px 25px rgba(0,0,0,0.1);
      border-radius: 12px;
      overflow: hidden;
    }

    #board {
      display: grid;
      grid-template-columns: repeat(5, var(--cell-size));
      grid-template-rows: repeat(7, var(--cell-size));
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 2;
    }

    .cell {
      width: var(--cell-size);
      height: var(--cell-size);
      display: flex;
      justify-content: center;
      align-items: center;
      box-sizing: border-box;
      border: none;
    }

    .dot {
      width: calc(var(--cell-size) * 0.5);
      height: calc(var(--cell-size) * 0.5);
      border-radius: 50%;
      z-index: 3;
    }

    .red { background: var(--red); }
    .yellow { background: var(--yellow); }
    .blue { background: var(--blue); }
    .purple { background: var(--purple); }

    canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
      pointer-events: none;
    }

    /* 연결 완료 버튼 (보드 위 중앙 배치) */
    #complete-button {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 50;
      display: none;
      background: #fbbf24;
      color: #1e293b;
      font-weight: 800;
      padding: 20px 40px;
      font-size: 20px;
      border-radius: 50px;
      box-shadow: 0 10px 30px rgba(251, 191, 36, 0.4);
      animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards, pulse 1.5s infinite;
      white-space: nowrap;
      border: 4px solid white;
    }

    @keyframes popIn {
      0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }

    @keyframes pulse {
      0% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.05); }
      100% { transform: translate(-50%, -50%) scale(1); }
    }

    /* 조작 버튼 스타일 */
    #arrows {
      display: grid;
      grid-template-areas:
        ". up ."
        "left down right";
      gap: 10px;
      justify-content: center;
    }

    .controls {
      display: flex;
      flex-direction: column;
      gap: 20px;
      align-items: center;
      margin-top: 30px;
      width: 100%;
    }

    .game-btn {
      padding: 14px 20px;
      font-size: 18px;
      background: #1e293b; 
      color: white;
      border: none;
      border-radius: 16px;
      cursor: pointer;
      transition: all 0.2s;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 64px;
      -webkit-tap-highlight-color: transparent;
    }

    .game-btn:active {
      transform: translateY(2px);
      box-shadow: 0 2px 3px rgba(0,0,0,0.1);
      filter: brightness(1.2);
    }

    #retry-btn {
      background: #64748b;
    }

    /* 알림 모달 스타일 */
    #modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.6);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 100;
      padding: 20px;
    }

    .modal-content {
      background: white;
      padding: 30px;
      border-radius: 20px;
      text-align: center;
      max-width: 320px;
      width: 100%;
      box-shadow: 0 20px 40px rgba(0,0,0,0.2);
    }
  </style>
</head>
<body>

  <div class="game-container">
    <div class="image-stack">
        <img src="https://raw.githubusercontent.com/realmetawinner/welcome-highschool/main/images/story7_1.png" alt="스토리 이미지 1">
        <img src="https://raw.githubusercontent.com/realmetawinner/welcome-highschool/main/images/story7_2.png" alt="스토리 이미지 2">
    </div>

    <div class="text-center mb-8 px-4">
        <h1 class="text-2xl md:text-3xl font-bold text-slate-800 mb-2">회로 연결 미션</h1>
        <p class="text-slate-500 text-sm md:text-base">같은 색의 단자를 화살표 버튼으로 연결하세요.</p>
    </div>

    <div id="game">
      <canvas id="canvas"></canvas>
      <div id="board"></div>
      <!-- 보드 위로 겹쳐서 나타날 버튼 -->
      <button id="complete-button" onclick="location.href='https://realmetawinner.github.io/welcome-highschool/story8.html'">⚡ 전력공급</button>
    </div>

    <div class="controls">
      <div id="arrows">
        <button class="game-btn" style="grid-area: up;" onclick="move('up')">↑</button>
        <button class="game-btn" style="grid-area: left;" onclick="move('left')">←</button>
        <button class="game-btn" style="grid-area: down;" onclick="move('down')">↓</button>
        <button class="game-btn" style="grid-area: right;" onclick="move('right')">→</button>
      </div>
      
      <div class="flex flex-col sm:flex-row gap-3 w-full justify-center items-center">
        <button id="retry-btn" class="game-btn w-full sm:w-auto" onclick="drawBoard()">다시 도전하기</button>
      </div>
    </div>
  </div>

  <!-- 팝업 모달 -->
  <div id="modal-overlay">
    <div class="modal-content">
      <h2 class="text-xl font-bold text-slate-800 mb-3">앗! 잘못된 연결</h2>
      <p class="text-slate-600 mb-6">다른 색끼리는 닿으면 안됩니다.</p>
      <button onclick="closeModalAndReset()" class="game-btn w-full !bg-slate-900">다시 시작하기</button>
    </div>
  </div>

<script>
  const board = document.getElementById('board');
  const completeButton = document.getElementById('complete-button');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const modalOverlay = document.getElementById('modal-overlay');
  
  const cols = 5, rows = 7;
  let currentColorIndex = 0;
  let currentPos = null;
  const colorOrder = ['yellow', 'red', 'blue', 'purple'];
  let drawnPaths = {};

  const level = [
    [0, 0, 'red'], [1, 3, 'red'],
    [0, 1, 'yellow'], [2, 0, 'yellow'],
    [0, 5, 'blue'], [4, 1, 'blue'],
    [1, 5, 'purple'], [4, 0, 'purple']
  ];

  function getCellSize() {
    return parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell-size'));
  }

  function resizeCanvas() {
    const size = getCellSize();
    if (!canvas) return;
    canvas.width = size * cols;
    canvas.height = size * rows;
    redrawCanvas();
  }

  function drawBoard() {
    const size = getCellSize();
    canvas.width = size * cols;
    canvas.height = size * rows;
    
    completeButton.style.display = 'none';
    board.innerHTML = '';
    
    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.x = x;
        cell.dataset.y = y;
        board.appendChild(cell);
      }
    }

    level.forEach(([x, y, color]) => {
      const cell = getCell(x, y);
      const dot = document.createElement('div');
      dot.className = `dot ${color}`;
      cell.appendChild(dot);
      cell.dataset.isDot = "true";
      cell.dataset.dotColor = color;
    });

    currentColorIndex = 0;
    drawnPaths = {};
    startColor(colorOrder[currentColorIndex]);
  }

  function getCell(x, y) {
    return board.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`);
  }

  function startColor(color) {
    const startPoint = level.find(([x, y, c]) => c === color);
    if (!startPoint) return;
    
    const [startX, startY] = startPoint;
    currentPos = { x: startX, y: startY };
    
    const cell = getCell(startX, startY);
    cell.dataset.lineColor = color;
    
    cell.style.backgroundColor = {
      red: 'rgba(244,67,54,0.08)',
      yellow: 'rgba(255,235,59,0.08)',
      blue: 'rgba(33,150,243,0.08)',
      purple: 'rgba(156,39,176,0.08)'
    }[color];
    
    drawnPaths[color] = [`${startX},${startY}`];
    redrawCanvas();
  }

  function move(direction) {
    if (!currentPos || currentColorIndex >= colorOrder.length) return;
    
    const delta = { up: [0,-1], down: [0,1], left: [-1,0], right: [1,0] }[direction];
    const newX = currentPos.x + delta[0];
    const newY = currentPos.y + delta[1];
    
    if (newX < 0 || newX >= cols || newY < 0 || newY >= rows) return;

    const cell = getCell(newX, newY);
    const color = colorOrder[currentColorIndex];
    const key = `${newX},${newY}`;

    // 충돌 체크 로직
    const hasOtherLine = cell.dataset.lineColor && cell.dataset.lineColor !== color;
    const hasOtherDot = cell.dataset.isDot === "true" && cell.dataset.dotColor !== color;

    if (hasOtherLine || hasOtherDot) {
      showResetModal();
      return;
    }

    if (drawnPaths[color].includes(key)) return; 

    cell.dataset.lineColor = color;
    drawnPaths[color].push(key);
    redrawCanvas();
    currentPos = { x: newX, y: newY };

    const sameColorPoints = level.filter(([x, y, c]) => c === color);
    const endPoint = sameColorPoints[1]; 
    
    if (newX === endPoint[0] && newY === endPoint[1]) {
      currentColorIndex++;
      if (currentColorIndex < colorOrder.length) {
        startColor(colorOrder[currentColorIndex]);
      } else {
        checkCompletion();
      }
    }
  }

  function showResetModal() {
    modalOverlay.style.display = 'flex';
  }

  function closeModalAndReset() {
    modalOverlay.style.display = 'none';
    drawBoard();
  }

  function checkCompletion() {
    let allFinished = true;
    for (const color of colorOrder) {
      if (!drawnPaths[color] || drawnPaths[color].length < 2) {
        allFinished = false;
        break;
      }
    }
    
    if (allFinished) {
      completeButton.style.display = 'block';
    }
  }

  function drawPath(color, path) {
    if (!path || path.length < 1) return;
    const size = getCellSize();
    
    ctx.beginPath();
    ctx.strokeStyle = {
      red: '#F44336', yellow: '#FBC02D', blue: '#2196F3', purple: '#9C27B0'
    }[color];
    ctx.lineWidth = size * 0.22;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    
    for (let i = 0; i < path.length; i++) {
      const [x, y] = path[i].split(',').map(Number);
      const cx = x * size + size / 2;
      const cy = y * size + size / 2;
      if (i === 0) ctx.moveTo(cx, cy);
      else ctx.lineTo(cx, cy);
    }
    ctx.stroke();
  }

  function redrawCanvas() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (const color of colorOrder) {
      if (drawnPaths[color]) drawPath(color, drawnPaths[color]);
    }
  }

  window.addEventListener('resize', () => {
    const oldSize = canvas.width / cols;
    const newSize = getCellSize();
    if (oldSize !== newSize) {
      resizeCanvas();
    }
  });

  window.onload = drawBoard;
</script>
</body>
</html>

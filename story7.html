
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ì»¬ëŸ¬ ì»¤ë„¥íŠ¸: íšŒë¡œ ì—°ê²° ë¯¸ì…˜</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            touch-action: none; /* ìŠ¤í¬ë¡¤ ë°©ì§€ */
            background-color: #f8fafc;
            -webkit-user-select: none;
            user-select: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 20px 10px;
        }
        
        /* ì´ë¯¸ì§€ ì»¨í…Œì´ë„ˆ ìŠ¤íƒ€ì¼ */
        .image-container {
            width: 100%;
            max-width: 600px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 20px;
        }
        .image-container img {
            width: 100%;
            height: auto;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1);
        }

        .cell {
            position: relative;
            aspect-ratio: 1 / 1;
            border: none;
            background: white;
            z-index: 10;
        }
        .dot {
            width: 60%;
            height: 60%;
            border-radius: 50%;
            z-index: 20;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 15;
        }
        .success-btn {
            animation: bounce 1s infinite;
        }
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }
    </style>
</head>
<body>

    <!-- ìƒë‹¨ ìŠ¤í† ë¦¬ ì´ë¯¸ì§€ ì˜ì—­ -->
    <div class="image-container">
        <img src="https://raw.githubusercontent.com/realmetawinner/welcome-highschool/main/images/story7_1.png" alt="ì´ë¯¸ì§€ 1">
        <img src="https://raw.githubusercontent.com/realmetawinner/welcome-highschool/main/images/story7_2.png" alt="ì´ë¯¸ì§€ 2">
    </div>

    <!-- ê²Œì„ ì œëª© ë° ì„¤ëª… -->
    <div class="text-center mb-6">
        <h1 class="text-3xl font-bold text-slate-800 mb-2">íšŒë¡œ ì—°ê²° ë¯¸ì…˜</h1>
        <p class="text-slate-500">ê°™ì€ ìƒ‰ì˜ ë‹¨ìë¥¼ ì„œë¡œ ê²¹ì¹˜ì§€ ì•Šê²Œ ì—°ê²°í•˜ì„¸ìš”.</p>
    </div>

    <!-- ê²Œì„íŒ -->
    <div class="relative bg-white p-2 rounded-xl shadow-2xl border-4 border-slate-200" id="board-container">
        <canvas id="game-canvas"></canvas>
        <div id="grid" class="grid grid-cols-5 grid-rows-7 gap-0" style="width: 300px; height: 420px;">
            <!-- Cells will be generated here -->
        </div>
    </div>

    <!-- ì»¨íŠ¸ë¡¤ ë²„íŠ¼ ì˜ì—­ -->
    <div class="flex flex-col items-center gap-4 mt-8">
        <div class="flex gap-4">
            <button onclick="resetGame()" class="flex items-center justify-center w-12 h-12 bg-white border-2 border-slate-200 rounded-full hover:bg-slate-50 transition-colors shadow-sm">
                <span class="text-xl">ğŸ”„</span>
            </button>
        </div>
        
        <button id="complete-button" 
                onclick="goToNextPage()"
                class="hidden success-btn px-8 py-3 bg-green-500 text-white font-bold rounded-xl shadow-lg hover:bg-green-600 transition-all">
            íšŒë¡œ ì—°ê²° ì™„ë£Œ! ì ì‹œ í›„ ì´ë™í•©ë‹ˆë‹¤...
        </button>
    </div>

    <script>
        const gridElement = document.getElementById('grid');
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const completeButton = document.getElementById('complete-button');
        const container = document.getElementById('board-container');

        const COLS = 5;
        const ROWS = 7;
        const CELL_SIZE = 60;
        const targetUrl = "https://realmetawinner.github.io/welcome-highschool/story8.html";

        const COLORS = {
            red: '#EF4444',
            green: '#22C55E',
            blue: '#3B82F6',
            purple: '#A855F7'
        };

        const DOTS = [
            {x: 0, y: 0, color: 'red'}, {x: 1, y: 3, color: 'red'},
            {x: 0, y: 1, color: 'green'}, {x: 2, y: 0, color: 'green'},
            {x: 0, y: 5, color: 'blue'}, {x: 4, y: 1, color: 'blue'},
            {x: 1, y: 5, color: 'purple'}, {x: 4, y: 0, color: 'purple'}
        ];

        let paths = { red: [], green: [], blue: [], purple: [] };
        let isDrawing = false;
        let currentColor = null;
        let lastCell = null;

        function initGrid() {
            gridElement.innerHTML = '';
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell flex items-center justify-center';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    
                    const dotData = DOTS.find(d => d.x === x && d.y === y);
                    if (dotData) {
                        const dot = document.createElement('div');
                        dot.className = 'dot';
                        dot.style.backgroundColor = COLORS[dotData.color];
                        cell.appendChild(dot);
                        cell.dataset.color = dotData.color;
                    }
                    
                    gridElement.appendChild(cell);
                }
            }
            resizeCanvas();
        }

        function resizeCanvas() {
            canvas.width = 300;
            canvas.height = 420;
            drawAllPaths();
        }

        function getCell(x, y) {
            const rect = gridElement.getBoundingClientRect();
            const cellX = Math.floor((x - rect.left) / CELL_SIZE);
            const cellY = Math.floor((y - rect.top) / CELL_SIZE);
            if (cellX >= 0 && cellX < COLS && cellY >= 0 && cellY < ROWS) {
                return { x: cellX, y: cellY };
            }
            return null;
        }

        function handleStart(e) {
            const pos = e.touches ? e.touches[0] : e;
            const cellPos = getCell(pos.clientX, pos.clientY);
            if (!cellPos) return;

            const cell = document.querySelector(`.cell[data-x="${cellPos.x}"][data-y="${cellPos.y}"]`);
            const color = cell.dataset.color;

            if (color) {
                isDrawing = true;
                currentColor = color;
                paths[color] = [{x: cellPos.x, y: cellPos.y}];
                lastCell = cellPos;
                drawAllPaths();
            }
        }

        function handleMove(e) {
            if (!isDrawing) return;
            if (e.touches) e.preventDefault();

            const pos = e.touches ? e.touches[0] : e;
            const cellPos = getCell(pos.clientX, pos.clientY);
            if (!cellPos) return;

            if (lastCell && (lastCell.x !== cellPos.x || lastCell.y !== cellPos.y)) {
                const dx = Math.abs(cellPos.x - lastCell.x);
                const dy = Math.abs(cellPos.y - lastCell.y);
                
                if ((dx === 1 && dy === 0) || (dx === 0 && dy === 1)) {
                    const isOtherColorPoint = DOTS.find(d => d.x === cellPos.x && d.y === cellPos.y && d.color !== currentColor);
                    if (isOtherColorPoint) return;

                    const existingIndex = paths[currentColor].findIndex(p => p.x === cellPos.x && p.y === cellPos.y);
                    if (existingIndex !== -1) {
                        paths[currentColor] = paths[currentColor].slice(0, existingIndex + 1);
                    } else {
                        let overlapped = false;
                        Object.keys(paths).forEach(c => {
                            if (c !== currentColor && paths[c].some(p => p.x === cellPos.x && p.y === cellPos.y)) {
                                overlapped = true;
                            }
                        });
                        if (overlapped) return;

                        paths[currentColor].push({x: cellPos.x, y: cellPos.y});
                        
                        const isTargetDot = DOTS.find(d => d.x === cellPos.x && d.y === cellPos.y && d.color === currentColor);
                        if (isTargetDot && paths[currentColor].length > 1) {
                            isDrawing = false;
                        }
                    }
                    lastCell = cellPos;
                    drawAllPaths();
                }
            }
        }

        function handleEnd() {
            if (!isDrawing) return;
            isDrawing = false;
            
            const last = paths[currentColor][paths[currentColor].length - 1];
            const isConnected = DOTS.some(d => d.x === last.x && d.y === last.y && d.color === currentColor && paths[currentColor].length > 1 && (last.x !== paths[currentColor][0].x || last.y !== paths[currentColor][0].y));
            
            if (!isConnected) {
                paths[currentColor] = [];
            }
            
            drawAllPaths();
            checkVictory();
        }

        function drawAllPaths() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.lineWidth = 12;

            Object.keys(paths).forEach(color => {
                const p = paths[color];
                if (p.length < 1) return;

                ctx.beginPath();
                ctx.strokeStyle = COLORS[color];
                
                p.forEach((point, index) => {
                    const cx = point.x * CELL_SIZE + CELL_SIZE / 2;
                    const cy = point.y * CELL_SIZE + CELL_SIZE / 2;
                    if (index === 0) ctx.moveTo(cx, cy);
                    else ctx.lineTo(cx, cy);
                });
                ctx.stroke();
            });
        }

        function checkVictory() {
            const allConnected = Object.keys(COLORS).every(color => {
                const p = paths[color];
                if (p.length < 2) return false;
                const start = p[0];
                const end = p[p.length - 1];
                const dots = DOTS.filter(d => d.color === color);
                return dots.some(d => d.x === start.x && d.y === start.y) && 
                       dots.some(d => d.x === end.x && d.y === end.y);
            });

            if (allConnected) {
                completeButton.classList.remove('hidden');
                // ëª¨ë“  ì„ ì´ ì—°ê²°ë˜ë©´ 0.8ì´ˆ í›„ ìë™ ì´ë™
                setTimeout(() => {
                    goToNextPage();
                }, 800);
            } else {
                completeButton.classList.add('hidden');
            }
        }

        function goToNextPage() {
            window.location.href = targetUrl;
        }

        function resetGame() {
            paths = { red: [], green: [], blue: [], purple: [] };
            completeButton.classList.add('hidden');
            drawAllPaths();
        }

        gridElement.addEventListener('mousedown', handleStart);
        window.addEventListener('mousemove', handleMove);
        window.addEventListener('mouseup', handleEnd);

        gridElement.addEventListener('touchstart', handleStart, {passive: false});
        window.addEventListener('touchmove', handleMove, {passive: false});
        window.addEventListener('touchend', handleEnd);

        initGrid();
    </script>
</body>
</html>
